(defpackage :cp/test/hermite-normal-form
  (:use :cl :fiveam :cp/hermite-normal-form)
  (:import-from :cp/test/base #:base-suite)
  (:import-from :cp/mod-linear-algebra #:mod-echelon!)
  (:import-from :cp/gemm #:gemm)
  (:import-from :cp/copy-array #:copy-array))
(in-package :cp/test/hermite-normal-form)
(in-suite base-suite)

(defun calc-rank (mat)
  (destructuring-bind (m n) (array-dimensions  mat)
    (let ((tmp (make-array (list m n) :element-type '(signed-byte 32))))
      (dotimes (i m)
        (dotimes (j n)
          (setf (aref tmp i j) (aref mat i j))))
      (nth-value 1 (mod-echelon! tmp #.(+ 7 (expt 10 9)))))))

(test hnf!/hand
  (declare (notinline hnf!))
  (let ((mat #2a((5 0 0 0) (3 1 0 0) (1 0 19 0) (4 0 16 3))))
    (multiple-value-bind (h u) (hnf! (copy-array mat))
      (is (equalp h #2a((5 0 0 0) (0 1 0 0) (1 0 19 0) (1 0 1 3))))
      (is (equalp (gemm #2a((5 0 0 0) (3 1 0 0) (1 0 19 0) (4 0 16 3)) u) h))))
  (multiple-value-bind (h u) (hnf! (copy-array #2a()))
    (is (equalp h #2a()))
    (is (equalp u #2a())))
  (multiple-value-bind (h u) (hnf! (make-array '(0 2) :element-type 'fixnum))
    (is (equalp h (make-array '(0 2) :element-type 'fixnum)))
    (is (equalp u #2a((1 0) (0 1))))))

(test hnf!/random
  (let ((*random-state* (sb-ext:seed-random-state 0))
        (*test-dribble* nil))
    (dolist (magnitute '(5 50))
      (loop with trial = 0
            for m = (+ 1 (random 8))
            for n = (+ 1 (random 8))
            until (=  trial 20000)
            when (> m n)
            do (rotatef m n)
            do (let ((mat (make-array (list m n) :element-type t :initial-element 0)))
                 (dotimes (i m)
                   (dotimes (j n)
                     (setf (aref mat i j) (- (random (* 2 magnitute)) magnitute))))
                 (let ((rank (calc-rank mat)))
                   (when (= rank m)
                     (multiple-value-bind (h1 u1) (hnf! (copy-array mat))
                       (let ((h2 (%hnf-fast! (copy-array mat))))
                         (is (equalp h1 (gemm mat u1)))
                         (is (equalp h1 h2))
                         (is (hnf-p h1))))
                     (incf trial))))))))

(test %hnf-fast!/hand
  (declare (notinline %hnf-fast!))
  (let* ((mat #2a((5 0 0 0) (3 1 0 0) (1 0 19 0) (4 0 16 3)))
         (h (%hnf-fast! (copy-array mat))))
    (is (equalp h #2a((5 0 0 0) (0 1 0 0) (1 0 19 0) (1 0 1 3)))))
  (is (equalp (%hnf-fast! (copy-array #2a())) #2a()))
  (is (equalp (%hnf-fast! (make-array '(0 2) :element-type 'fixnum))
              (make-array '(0 2) :element-type 'fixnum))))

(test %hnf-fast!/random
  (let ((*random-state* (sb-ext:seed-random-state 0))
        (*test-dribble* nil))
    ;; Numbers that appear in the computation should be within fixnum because of
    ;; the Hadamard bound: sqrt(50^2 * 8)^8 ~ 1.6e17 < 4.6e18 ~ 2^62
    (dolist (magnitute '(5 50))
      (loop with trial = 0
            for m = (+ 1 (random 8))
            for n = (+ 1 (random 8))
            until (=  trial 20000)
            when (> m n)
            do (rotatef m n)
            do (let ((mat (make-array (list m n) :element-type 'fixnum :initial-element 0)))
                 (dotimes (i m)
                   (dotimes (j n)
                     (setf (aref mat i j) (- (random (* 2 magnitute)) magnitute))))
                 (let ((rank (calc-rank mat)))
                   (when (= rank m)
                     (let ((h (finishes (%hnf-fast! mat))))
                       (is (hnf-p h)))
                     (incf trial))))))))

(defun hnf-test (mag)
  (declare (optimize (speed 3))
           ((integer 0 100) mag))
  (loop with trial of-type fixnum = 0
        for m = (+ 1 (random 10))
        for n = (+ 1 (random 10))
        until (=  trial 100000)
        when (> m n)
        do (rotatef m n)
        do (let ((mat (make-array (list m n) :element-type 'fixnum :initial-element 0)))
             (dotimes (i m)
               (dotimes (j n)
                 (setf (aref mat i j) (- (random (* 2 mag)) mag))))
             (let ((rank (calc-rank mat)))
               (declare (fixnum rank))
               (when (= rank m)
                 (let ((h (%hnf-fast! mat)))
                   (hnf-p h))
                 (incf trial))))))
