(defpackage :cp/lll
  (:use :cl)
  (:export #:lll-fractional #:lll)
  (:documentation "Provides an LLL algorithm for the basis reduction.

Reference:
- Hoffstein, Pipher, Silverman. An Introduction to Mathematical Cryptography,
  2nd edition.
- Ulfar Erlingsson, Erich Kaltofen, David Musser. Generic Gram-Schmidt
  Orthogonalization by Exact Division."))
(in-package :cp/lll)

;; TODO: handling row vectors instead of column might be better in terms of the
;; locality of reference (though the bottleneck should be the operations of
;; bignums in most cases).

(defun rational-gram-schmidt (mat)
  (declare ((simple-array * (* *)) mat))
  (destructuring-bind (m n) (array-dimensions mat)
    (declare ((mod #.array-dimension-limit) m n))
    (assert (>= m n))
    (let* ((ort (make-array (list m n) :element-type t))
           (coefs (make-array (list n n) :element-type t :initial-element 0))
           (l2s (make-array n :element-type t)))
      (dotimes (col n)
        (dotimes (i m)
          (setf (aref ort i col) (aref mat i col)))
        (dotimes (precol col)
          (let ((coef (/ (loop for i below m
                               sum (* (aref mat i col) (aref ort i precol)))
                         (aref l2s precol))))
            (setf (aref coefs col precol) coef)
            (dotimes (i m)
              (decf (aref ort i col) (* coef (aref ort i precol))))))
        (setf (aref l2s col)
              (loop for i below m
                    sum (expt (aref ort i col) 2))))
      (values ort coefs l2s))))

(defun lll-fractional (mat &optional (delta 3/4))
  "Applies the basis reduction to the given rational column vectors.

NOTE: MAT should have full column rank. Otherwise the consequence is undefined."
  (declare (optimize (speed 3))
           ((array * (* *)) mat)
           ((rational (1/4) 1) delta))
  (destructuring-bind (m n) (array-dimensions mat)
    (declare ((mod #.array-dimension-limit) m n))
    (let ((mat
            (let ((tmp (make-array (list m n) :element-type 'rational)))
              (dotimes (i m tmp)
                (dotimes (j n)
                  (setf (aref tmp i j) (aref mat i j))))))
          (l2s (make-array n :element-type 'rational))
          (ort-mat (make-array (list m n) :element-type 'rational))
          (coefs (make-array (list m n) :element-type 'rational))
          (max-pos -1)
          (pos 0))
      (declare ((simple-array rational (*)) l2s)
               ((simple-array rational (* *)) mat ort-mat coefs))
      (labels ((%reduce (target-pos pivot-pos)
                 (when (> (abs (* 2 (aref coefs target-pos pivot-pos))) 1)
                   (let ((rounded-mu (round (aref coefs target-pos pivot-pos))))
                     (dotimes (i m)
                       (decf (aref mat i target-pos)
                             (* rounded-mu (aref mat i pivot-pos))))
                     (decf (aref coefs target-pos pivot-pos) rounded-mu)
                     (dotimes (j pivot-pos)
                       (decf (aref coefs target-pos j)
                             (* rounded-mu (aref coefs pivot-pos j)))))))
               (%swap (pos)
                 (dotimes (i m)
                   (rotatef (aref mat i (- pos 1)) (aref mat i pos)))
                 (dotimes (j (- pos 1))
                   (rotatef (aref coefs (- pos 1) j) (aref coefs pos j)))
                 (let* ((old-mu (aref coefs pos (- pos 1)))
                        (new-l2 (+ (aref l2s pos)
                                   (* (expt old-mu 2) (aref l2s (- pos 1))))))
                   (declare (rational old-mu new-l2))
                   (setf (aref coefs pos (- pos 1))
                         (/ (* old-mu (aref l2s (- pos 1))) new-l2))
                   (setf (aref l2s pos)
                         (/ (* (aref l2s (- pos 1)) (aref l2s pos)) new-l2))
                   (setf (aref l2s (- pos 1)) new-l2)
                   (dotimes (i m)
                     (let* ((old-ort (aref ort-mat i (- pos 1)))
                            (new-ort (+ (aref ort-mat i pos)
                                        (* old-mu old-ort))))
                       (setf (aref ort-mat i (- pos 1)) new-ort)
                       (setf (aref ort-mat i pos)
                             (- old-ort (* (aref coefs pos (- pos 1)) new-ort)))))
                   (loop for j from (+ pos 1) to max-pos
                         for mu = (aref coefs j pos)
                         do (setf (aref coefs j pos)
                                  (- (aref coefs j (- pos 1)) (* old-mu mu)))
                            (setf (aref coefs j (- pos 1))
                                  (+ mu (* (aref coefs pos (- pos 1))
                                           (aref coefs j pos))))))))
        (loop
          (when (= pos n)
            (return))
          (when (> pos max-pos)
            ;; add new column
            (assert (= (+ max-pos 1) pos))
            (setq max-pos pos)
            ;; naive way: recompute Gram-Schmidt basis each time
            ;; (multiple-value-setq (ort-mat coefs l2s)
            ;;   (rational-gram-schmidt mat))
            (dotimes (i m)
              (setf (aref ort-mat i pos) (aref mat i pos)))
            (dotimes (j pos)
              (let ((mu (/ (loop for i below m
                                 sum (* (aref mat i pos) (aref ort-mat i j))
                                 of-type rational)
                           (aref l2s j))))
                (setf (aref coefs pos j) mu)
                (dotimes (i m)
                  (decf (aref ort-mat i pos) (* mu (aref ort-mat i j))))))
            (setf (aref l2s pos)
                  (loop for i below m
                        sum (expt (aref ort-mat i pos) 2)
                        of-type rational)))
          (if (zerop pos)
              (incf pos)
              (loop
                (%reduce pos (- pos 1))
                (if (< (aref l2s pos)
                       (* (- delta (expt (aref coefs pos (- pos 1)) 2))
                          (aref l2s (- pos 1))))
                    (progn
                      (%swap pos)
                      (setq pos (max 1 (- pos 1))))
                    (progn
                      (loop for pivot-pos from (- pos 2) downto 0
                            do (%reduce pos pivot-pos))
                      (incf pos)
                      (return))))))
        mat))))

;; FIXME: This is just for validating this implementation. I will discard it
;; when I believe this module is stable.
(declaim (inline %div))
(defun %div (x y)
  (declare (integer x y))
  (multiple-value-bind (quot rem) (floor x y)
    (assert (zerop rem))
    quot))

(defun lll (mat &optional (delta 3/4))
  "Applies the basis reduction to the given integer column vectors.

NOTE: MAT should have full column rank. Otherwise the consequence is undefined."
  (declare (optimize (speed 3))
           ((array * (* *)) mat)
           ((rational (1/4) 1) delta))
  (destructuring-bind (m n) (array-dimensions mat)
    (declare ((mod #.array-dimension-limit) m n))
    (let ((mat
            (let ((tmp (make-array (list m n) :element-type 'integer)))
              (dotimes (i m tmp)
                (dotimes (j n)
                  (setf (aref tmp i j) (aref mat i j))))))
          (l2s (make-array n :element-type 'integer))
          (det2s (make-array (+ n 1) :element-type 'integer))
          (ort-mat (make-array (list m n) :element-type 'integer))
          (coefs (make-array (list m n) :element-type 'integer))
          (max-pos -1)
          (pos 0))
      (declare ((simple-array integer (*)) l2s det2s)
               ((simple-array integer (* *)) mat ort-mat coefs))
      (setf (aref det2s 0) 1)
      (labels ((%reduce (target-pos pivot-pos)
                 (let ((pivot-det2 (aref det2s (+ pivot-pos 1))))
                   (when (> (abs (* 2 (aref coefs target-pos pivot-pos))) pivot-det2)
                     (let ((rounded-mu (round (aref coefs target-pos pivot-pos) pivot-det2)))
                       (dotimes (i m)
                         (decf (aref mat i target-pos)
                               (* rounded-mu (aref mat i pivot-pos))))
                       (decf (aref coefs target-pos pivot-pos)
                             (* rounded-mu pivot-det2))
                       (dotimes (j pivot-pos)
                         (decf (aref coefs target-pos j)
                               (* rounded-mu (aref coefs pivot-pos j))))))))
               (%swap (pos)
                 (dotimes (i m)
                   (rotatef (aref mat i (- pos 1)) (aref mat i pos)))
                 (dotimes (j (- pos 1))
                   (rotatef (aref coefs (- pos 1) j) (aref coefs pos j)))
                 (let* ((prec-det2 (aref det2s (- pos 1)))
                        (det2 (aref det2s pos))
                        (old-mu (aref coefs pos (- pos 1)))
                        (new-l2 (%div (+ (* (expt prec-det2 2)
                                            (aref l2s pos))
                                         (* (expt old-mu 2) (aref l2s (- pos 1))))
                                      (expt det2 2)))
                        (new-det2 (%div (* det2 new-l2) (aref l2s (- pos 1)))))
                   (setf (aref coefs pos (- pos 1))
                         (%div (* new-det2 old-mu (aref l2s (- pos 1)))
                               (* det2 new-l2)))
                   (setf (aref l2s pos)
                         (%div (* (expt new-det2 2)
                                  (aref l2s (- pos 1))
                                  (aref l2s pos))
                               (* (expt det2 2) new-l2)))
                   (setf (aref l2s (- pos 1)) new-l2)
                   (dotimes (i m)
                     (let* ((old-ort (aref ort-mat i (- pos 1)))
                            (new-ort (%div (+ (* prec-det2 (aref ort-mat i pos))
                                              (* old-mu old-ort))
                                           det2)))
                       (setf (aref ort-mat i (- pos 1)) new-ort)
                       (setf (aref ort-mat i pos)
                             (%div (- (* new-det2 old-ort)
                                      (* (aref coefs pos (- pos 1)) new-ort))
                                   prec-det2))))
                   (loop with next-det2 = (aref det2s (+ pos 1))
                         for j from (+ pos 1) to max-pos
                         for mu = (aref coefs j pos)
                         do (setf (aref coefs j pos)
                                  (%div (- (* next-det2 (aref coefs j (- pos 1)))
                                           (* old-mu mu))
                                        det2))
                            (setf (aref coefs j (- pos 1))
                                  (%div (+ (* new-det2 mu)
                                           (* (aref coefs pos (- pos 1))
                                              (aref coefs j pos)))
                                        next-det2)))
                   (setf (aref det2s pos) new-det2))))
        (loop
          (when (= pos n)
            (return))
          (when (> pos max-pos)
            ;; add new column
            (assert (= (+ max-pos 1) pos))
            (setq max-pos pos)
            (dotimes (i m)
              (setf (aref ort-mat i pos) (aref mat i pos)))
            (dotimes (j pos)
              (let* ((det2 (aref det2s j))
                     (next-det2 (aref det2s (+ j 1)))
                     (mu (%div (* (loop for i below m
                                        sum (* (aref mat i pos) (aref ort-mat i j))
                                        of-type rational)
                                  det2
                                  next-det2)
                               (aref l2s j))))
                (setf (aref coefs pos j) mu)
                (dotimes (i m)
                  (setf (aref ort-mat i pos)
                        (%div (- (* next-det2 (aref ort-mat i pos))
                                 (* mu (aref ort-mat i j)))
                              det2)))))
            (setf (aref l2s pos)
                  (loop for i below m
                        sum (expt (aref ort-mat i pos) 2)
                        of-type rational))
            (setf (aref det2s (+ pos 1))
                  (%div (aref l2s pos) (aref det2s pos))))
          (if (zerop pos)
              (incf pos)
              (loop
                (%reduce pos (- pos 1))
                (if (< (* (denominator delta)
                          (+ (* (expt (aref det2s (- pos 1)) 2)
                                (aref l2s pos))
                             (* (expt (aref coefs pos (- pos 1)) 2)
                                (aref l2s (- pos 1)))))
                       (* (numerator delta)
                          (expt (aref det2s pos) 2)
                          (aref l2s (- pos 1))))
                    (progn
                      (%swap pos)
                      (setq pos (max 1 (- pos 1))))
                    (progn
                      (loop for pivot-pos from (- pos 2) downto 0
                            do (%reduce pos pivot-pos))
                      (incf pos)
                      (return))))))
        mat))))
