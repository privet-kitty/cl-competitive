(defpackage :cp/exact-division
  (:use :cl :cp/mod-inverse :cp/extend-vector :cp/tzcount :cp/xor)
  (:export :with-exact-division))
(in-package :cp/exact-division)

(defconstant +default-cache-length+ 8)

(declaim (inline power-of-two-ceiling))
(defun power-of-two-ceiling (x)
  (ash 1 (integer-length (- x 1))))

(declaim (inline oddify))
(defun oddify (integer)
  (declare (unsigned-byte integer))
  (let ((n-trailing-zeros (tzcount integer)))
    (values (ash integer (- n-trailing-zeros))
            n-trailing-zeros)))

(defmacro with-exact-division ((divisor function-name) &body body)
  "Provides a local exact division function by a fixed DIVISOR."
  (let ((inv-cache (gensym))
        (inv-cached-p (gensym))
        (_divisor (gensym))
        (divisor-plus-p (gensym))
        (odd-divisor (gensym))
        (divisor-tzcount (gensym)))
    `(let* ((,_divisor ,divisor)
            (,divisor-plus-p (plusp ,_divisor))
            (,inv-cache (load-time-value (make-array +default-cache-length+
                                                     :element-type t
                                                     :adjustable t)))
            (,inv-cached-p 0))
       (declare (unsigned-byte ,inv-cached-p)
                (integer ,_divisor))
       (multiple-value-bind (,odd-divisor ,divisor-tzcount) (oddify (abs ,_divisor))
         (labels ((,function-name (dividend)
                    (declare (integer dividend))
                    (if (typep dividend 'fixnum)
                        (nth-value 0 (floor dividend ,_divisor))
                        (let* ((n-bits (integer-length (abs dividend)))
                               (n-bits-ceil (power-of-two-ceiling n-bits))
                               (n-bits-index (- (integer-length n-bits-ceil) 1)))
                          (unless (logbitp n-bits-index ,inv-cached-p)
                            (extend-vectorf ,inv-cache (+ 1 n-bits-index))
                            (setf (aref ,inv-cache n-bits-index)
                                  (mod-inverse ,odd-divisor (ash 1 n-bits-ceil)))
                            (setf (ldb (byte 1 n-bits-index) ,inv-cached-p) 1))
                          (let ((res (ldb (byte n-bits-ceil 0)
                                          (* (ash (abs dividend) (- ,divisor-tzcount))
                                             (aref ,inv-cache n-bits-index)))))
                            (if (xor ,divisor-plus-p (plusp dividend))
                                (- res)
                                res))))))
           ,@body)))))
